[
  {
    "algorithm": "Recursive Binary Search Tree (BST) Insert",
    "input": [
      "newroot - Pointer to the current node (subtree root) being considered.",
      "value - The integer value to insert."
    ],
    "output": [
      "Pointer to the (potentially modified) root of the subtree where insertion occurred."
    ],
    "steps": [
      {
        "step": "Base Case: If `newroot` is `nullptr` (empty spot found):",
        "substeps": [
          {
            "step": "Create a new node using `createnewnode(value)`."
          },
          {
            "step": "Set `newroot` to point to this new node."
          },
          {
            "step": "Return `newroot`."
          }
        ]
      },
      {
        "step": "Recursive Step: If `newroot` is not `nullptr`:" ,
        "substeps": [
            {
                "step": "If `value` is less than `newroot->data`:",
                 "substeps": [
                    {
                        "step": "Recursively call `insert` on the left child: `newroot->left = insert(newroot->left, value)`."
                    }
                 ]
            },
             {
                "step": "Else (if `value` is greater than or equal to `newroot->data`):",
                 "substeps": [
                    {
                        "step": "Recursively call `insert` on the right child: `newroot->right = insert(newroot->right, value)`."
                    }
                 ]
            }
        ]
      },
      {
          "step": "Return the original (or potentially modified) `newroot` pointer."
      }
    ]
  },
   {
    "algorithm": "Recursive Preorder Traversal",
    "input": [
      "current - Pointer to the current node being visited."
    ],
    "output": [
      "Prints the data of nodes in Preorder (Root-Left-Right) sequence to standard output."
    ],
    "steps": [
      {
        "step": "If `current` is not `nullptr`:",
        "substeps": [
          {
            "step": "Visit/Process the current node (Print `current->data`)."
          },
          {
            "step": "Recursively call `preorder` on the left child: `preorder(current->left)`."
          },
          {
            "step": "Recursively call `preorder` on the right child: `preorder(current->right)`."
          }
        ]
      }
    ]
  },
  {
    "algorithm": "Recursive Inorder Traversal",
    "input": [
      "current - Pointer to the current node being visited."
    ],
    "output": [
      "Prints the data of nodes in Inorder (Left-Root-Right) sequence to standard output."
    ],
    "steps": [
      {
        "step": "If `current` is not `nullptr`:",
        "substeps": [
          {
            "step": "Recursively call `inorder` on the left child: `inorder(current->left)`."
          },
          {
            "step": "Visit/Process the current node (Print `current->data`)."
          },
          {
            "step": "Recursively call `inorder` on the right child: `inorder(current->right)`."
          }
        ]
      }
    ]
  },
  {
    "algorithm": "Recursive Postorder Traversal",
    "input": [
      "current - Pointer to the current node being visited."
    ],
    "output": [
      "Prints the data of nodes in Postorder (Left-Right-Root) sequence to standard output."
    ],
    "steps": [
      {
        "step": "If `current` is not `nullptr`:",
        "substeps": [
          {
            "step": "Recursively call `postorder` on the left child: `postorder(current->left)`."
          },
          {
            "step": "Recursively call `postorder` on the right child: `postorder(current->right)`."
          },
          {
            "step": "Visit/Process the current node (Print `current->data`)."
          }
        ]
      }
    ]
  },
  {
    "algorithm": "Iterative Binary Search Tree (BST) Search",
    "input": [
      "value - The integer value to search for."
    ],
    "output": [
      "Prints whether the `value` was found in the tree to standard output."
    ],
    "steps": [
      {
        "step": "Initialize a temporary pointer `temp = root`."
      },
      {
        "step": "Initialize a flag `flag = 0` (0 means not found, 1 means found)."
      },
      {
        "step": "While `temp` is not `nullptr`:",
        "substeps": [
          {
            "step": "If `value` is equal to `temp->data`:",
            "substeps": [
              {
                "step": "Set `flag = 1`."
              },
              {
                "step": "Break out of the loop."
              }
            ]
          },
          {
            "step": "Else:",
             "substeps": [
                {
                    "step": "If `value` is less than `temp->data`:",
                     "substeps": [
                        {
                            "step": "Move to the left child: `temp = temp->left`."
                        }
                     ]
                },
                {
                    "step": "Else if `value` is greater than `temp->data`:",
                     "substeps": [
                        {
                             "step": "Move to the right child: `temp = temp->right`."
                        }
                     ]
                }
             ]
          }
        ]
      },
      {
        "step": "After the loop, check the `flag`:" ,
        "substeps": [
            {
                "step": "If `flag` is 1, print that the `value` was found."
            },
             {
                "step": "Else (if `flag` is 0), print that the `value` was not found."
            }
        ]
      }
    ]
  }
]
