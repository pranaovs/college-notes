[
  {
    "algorithm": "Max Heapify Up (Percolate Up)",
    "input": [
      "heap - The vector representing the heap (1-based indexing).",
      "cur - The index of the next available position (one position after the newly inserted element)."
    ],
    "output": [
      "The heap property is restored for the element initially at index `cur - 1`."
    ],
    "steps": [
      {
        "step": "Set `current_index = cur - 1` (index of the element to heapify up)."
      },
      {
        "step": "While `current_index` is greater than 1 (not the root) AND the parent element (`heap[current_index / 2]`) is less than the current element (`heap[current_index]`):",
        "substeps": [
          {
            "step": "Swap the current element (`heap[current_index]`) with its parent (`heap[current_index / 2]`)."
          },
          {
            "step": "Update `current_index` to the parent's index: `current_index = current_index / 2`."
          }
        ]
      }
    ]
  },
  {
    "algorithm": "Max Heapify Down (Percolate Down)",
    "input": [
      "heap - The vector representing the heap (1-based indexing).",
      "cur - The index of the next available position (size of the heap + 1)."
    ],
    "output": [
      "The heap property is restored starting from the root (index 1)."
    ],
    "steps": [
      {
        "step": "Set `current_index = 1` (start at the root)."
      },
      {
        "step": "While a left child exists (`current_index * 2 < cur`):",
        "substeps": [
          {
            "step": "Calculate the left child index: `left_child = current_index * 2`."
          },
          {
            "step": "Calculate the right child index: `right_child = left_child + 1`."
          },
          {
            "step": "Assume the left child is the larger child: `larger_child_index = left_child`."
          },
          {
            "step": "Check if the right child exists (`right_child < cur`) AND the right child is greater than the left child (`heap[right_child] > heap[left_child]`):",
            "substeps": [
              {
                "step": "If true, update the larger child index: `larger_child_index = right_child`."
              }
            ]
          },
          {
            "step": "Check if the current node is greater than or equal to its largest child (`heap[current_index] >= heap[larger_child_index]`):",
            "substeps": [
                {
                   "step": "If true, the heap property holds at this subtree, break the loop."
                }
            ]
          },
          {
            "step": "If the current node is smaller than its largest child:",
            "substeps": [
              {
                "step": "Swap the current node (`heap[current_index]`) with the larger child (`heap[larger_child_index]`)."
              },
              {
                "step": "Update `current_index` to the index of the child it was swapped with: `current_index = larger_child_index`."
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "algorithm": "Max Heap Insert",
    "input": [
      "value - The integer value to insert into the heap."
    ],
    "output": [
      "The `value` is added to the heap, maintaining the max heap property."
    ],
    "steps": [
      {
        "step": "Add the `value` to the end of the `heap` vector (using `push_back`)."
      },
      {
        "step": "Increment the current size counter `cur`."
      },
      {
        "step": "Call `heapifyup()` to restore the heap property by moving the newly added element up to its correct position."
      }
    ]
  },
  {
    "algorithm": "Max Heap Delete (Extract Max)",
    "input": [
      "None"
    ],
    "output": [
      "max_value - The largest value (root) removed from the heap. Returns -1 if the heap is empty."
    ],
    "steps": [
      {
        "step": "Check if the heap is empty (`cur == 1`).",
        "substeps": [
           {
               "step": "If true, print an error message and return -1."
           }
        ]
      },
      {
        "step": "Store the value of the root element (maximum value): `max_value = heap[1]`."
      },
      {
        "step": "Move the last element of the heap to the root position: `heap[1] = heap[cur - 1]`."
      },
      {
        "step": "Remove the last element from the `heap` vector (using `pop_back`)."
      },
      {
        "step": "Decrement the current size counter `cur`."
      },
      {
        "step": "Call `heapifydown()` to restore the heap property by moving the new root element down to its correct position."
      },
      {
        "step": "Return the stored `max_value`."
      }
    ]
  },
  {
    "algorithm": "Heap Sort (using Max Heap)",
    "input": [
      "None (operates on the internal heap structure)."
    ],
    "output": [
      "Prints the elements of the original heap in descending sorted order to standard output."
    ],
    "steps": [
       {
        "step": "Create an empty vector `sorted_list` to store the sorted elements."
      },
      {
        "step": "Store the original heap size (`originalCur = cur`) and the original heap contents (`originalHeap = heap`) to allow restoration later."
      },
      {
        "step": "While the heap is not empty (`cur > 1`):",
         "substeps": [
            {
               "step": "Call `del()` to extract the maximum element from the heap."
            },
            {
                "step": "Add the extracted maximum element to the `sorted_list`."
            }
         ]
      },
      {
        "step": "Print the elements in the `sorted_list` (which are now in descending order)."
      },
      {
        "step": "Restore the heap's original state: `heap = originalHeap`, `cur = originalCur`."
      }
    ]
  }
]
