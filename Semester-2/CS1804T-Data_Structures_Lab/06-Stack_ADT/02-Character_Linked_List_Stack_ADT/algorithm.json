[
  {
    "algorithm": "Stack Push (via LList::insertend -> LList::insertpos)",
    "input": [
      "element - The character to push onto the stack"
    ],
    "output": [
      "None (Stack is modified in place)"
    ],
    "steps": [
      {
        "step": "Handle insertion at the beginning (pos == 0):",
        "substeps": [
          {
            "step": "Call `new_node(element, head)` to create a new node whose `next` points to the current head."
          },
          {
            "step": "Update the list's `head` to point to the newly created node."
          },
          {
             "step": "Increment `count` and update `size` within `new_node`."
          }
        ]
      },
      {
        "step": "Handle insertion at other positions (pos > 0), including the end (pos == count):",
        "substeps": [
          {
            "step": "Initialize a temporary pointer `tmp` to `head`."
          },
          {
            "step": "Traverse the list: For i from 0 to `pos - 2` (to reach the node *before* the insertion point):",
             "substeps": [
                {
                    "step": "Move `tmp` to `tmp->next`."
                }
             ]
          },
          {
            "step": "Call `new_node(element, tmp->next)` to create a new node whose `next` points to the node currently after `tmp`."
          },
          {
             "step": "Increment `count` and update `size` within `new_node`."
          },
          {
            "step": "Update `tmp->next` to point to the newly created node."
          }
        ]
      }
    ]
  },
  {
    "algorithm": "Stack Pop (via LList::deleteend -> LList::deletepos)",
    "input": [
      "None"
    ],
    "output": [
      "element - The character popped from the top of the stack"
    ],
    "steps": [
      {
        "step": "Check for underflow: If the position `pos` (which is `count - 1`) is invalid (less than 0 or greater than or equal to `count`), throw an 'Invalid position' exception."
      },
      {
        "step": "Initialize a temporary pointer `tmp` to `head`."
      },
      {
        "step": "Handle deletion from the beginning (pos == 0):",
        "substeps": [
          {
            "step": "Update `head` to point to `tmp->next` (the second node)."
          },
          {
            "step": "Store the data from the original head (`tmp->data`) into a variable `ele`."
          },
          {
            "step": "Call `delete_node(tmp)` to deallocate the original head node and decrement `count`/`size`."
          },
          {
             "step": "Return `ele`."
          }
        ]
      },
      {
        "step": "Handle deletion from other positions (pos > 0), including the end (pos == count - 1):",
        "substeps": [
           {
            "step": "Traverse the list: For i from 0 to `pos - 2` (to reach the node *before* the one to be deleted):",
             "substeps": [
                {
                    "step": "Move `tmp` to `tmp->next`."
                }
             ]
           },
           {
             "step": "Create a pointer `to_delete` pointing to the node to be deleted (`tmp->next`)."
           },
           {
             "step": "Store the data from the node to be deleted (`to_delete->data`) into a variable `ele`."
           },
           {
             "step": "Update the `next` pointer of the preceding node (`tmp`) to skip the node being deleted: `tmp->next = to_delete->next`."
           },
           {
             "step": "Call `delete_node(to_delete)` to deallocate the target node and decrement `count`/`size`."
           },
           {
             "step": "Return `ele`."
           }
        ]
      }
    ]
  },
  {
    "algorithm": "Stack Top (via LList::get)",
    "input": [
      "None (Implicitly uses `count - 1` as the position)"
    ],
    "output": [
      "element - The character at the top of the stack"
    ],
    "steps": [
      {
        "step": "Calculate effective position: `pos = (count - 1) % count`."
      },
      {
         "step": "Initialize a temporary pointer `tmp` to `head`."
      },
      {
        "step": "Traverse the list: For i from 0 to `pos - 1`:",
        "substeps": [
            {
                "step": "Move `tmp` to `tmp->next`."
            }
        ]
      },
      {
          "step": "Return the data stored in the current node `tmp->data`."
      }
    ]
  }
]
