[
  {
    "algorithm": "LList Destructor",
    "input": [
      "Implicitly takes the LList object instance."
    ],
    "output": [
      "All nodes in the linked list are deallocated.",
      "The list becomes empty (`head` is null, `count` and `size` are 0)."
    ],
    "steps": [
      {
        "step": "Initialize `current_node = head`."
      },
      {
        "step": "Initialize `next_node = nullptr`."
      },
      {
        "step": "While `current_node` is not `nullptr`:",
        "substeps": [
          {
            "step": "Store the next node: `next_node = current_node->next`."
          },
          {
            "step": "Deallocate the `current_node` (using `delete_node` logic, which also decrements count/size)."
          },
          {
            "step": "Move to the next node: `current_node = next_node`."
          }
        ]
      },
      {
        "step": "Set `head = nullptr`."
      },
      {
        "step": "Set `count = 0`."
      },
      {
        "step": "Set `size = 0`."
      }
    ]
  },
    {
    "algorithm": "LList Allocate and Copy Range",
    "input": [
      "ptr: A pointer to an integer pointer (int**) where the copied array will be stored.",
      "start: The starting zero-based index of the sublist to copy.",
      "end: The ending zero-based index of the sublist to copy."
    ],
    "output": [
      "Returns the number of elements copied (end - start + 1) on success.",
      "Returns -1 if indices are invalid.",
      "Allocates a new integer array pointed to by `*ptr` containing elements from index `start` to `end`."
    ],
    "steps": [
      {
        "step": "Check if `start < 0` or `end >= count`."
      },
      {
        "step": "If indices are invalid, return -1."
      },
      {
        "step": "Calculate the required array size: `arr_size = end - start + 1`."
      },
      {
        "step": "Allocate memory for the new array: `*ptr = new int[arr_size]`."
      },
      {
        "step": "Call the `copy(ptr, start, end)` function to populate the allocated array."
      },
      {
        "step": "Return the number of elements copied (`arr_size`)."
      }
    ]
  },
  {
    "algorithm": "LList Insert at Position",
    "input": [
      "ele: The integer element to insert.",
      "pos: The zero-based index at which to insert the element."
    ],
    "output": [
      "Returns `true` if insertion is successful, `false` otherwise.",
      "A new node containing `ele` is inserted at index `pos`.",
      "The list size increases by 1."
    ],
    "steps": [
      {
        "step": "Check if the position `pos` is valid (from $0$ to `count` inclusive)."
      },
      {
        "step": "If `pos` is invalid, return `false`."
      },
      {
        "step": "If `pos == 0` (insert at beginning):",
        "substeps": [
          {
            "step": "Create a new node `new_node` with data `ele` and `next` pointing to the current `head` (using `new_node` logic, which also increments count/size)."
          },
          {
            "step": "Update the list's `head` to point to `new_node`."
          },
          {
            "step": "Return `true`."
          }
        ]
      },
      {
        "step": "Else (insert at `pos > 0`):",
        "substeps": [
          {
            "step": "Initialize `temp_node = head`."
          },
          {
            "step": "Iterate `pos - 1` times to reach the node *before* the insertion point: `temp_node = temp_node->next`."
          },
          {
            "step": "Create a new node `new_node` with data `ele` and `next` pointing to `temp_node->next` (using `new_node` logic)."
          },
          {
            "step": "Update the `next` pointer of `temp_node` to point to `new_node`: `temp_node->next = new_node`."
          },
          {
            "step": "Return `true`."
          }
        ]
      }
    ]
  },
  {
    "algorithm": "LList Delete at Position",
    "input": [
      "pos: The zero-based index from which to delete the element."
    ],
    "output": [
      "Returns the integer element that was deleted.",
      "The node at index `pos` is removed and deallocated.",
      "The list size decreases by 1.",
      "Throws an exception or indicates an error if `pos` is invalid."
    ],
    "steps": [
      {
        "step": "Check if `pos < 0` or `pos >= count`."
      },
      {
        "step": "If invalid, throw an exception or signal an error ('Invalid position')."
      },
      {
        "step": "Initialize `temp_node = head`."
      },
      {
        "step": "If `pos == 0` (delete head):",
        "substeps": [
          {
            "step": "Update `head` to point to the next node: `head = temp_node->next`."
          },
          {
            "step": "Store the data from the node to be deleted: `deleted_element = temp_node->data`."
          },
          {
            "step": "Deallocate the original head node `temp_node` (using `delete_node` logic, which also decrements count/size)."
          },
          {
            "step": "Return `deleted_element`."
          }
        ]
      },
      {
        "step": "Else (delete at `pos > 0`):",
        "substeps": [
          {
            "step": "Iterate `pos - 1` times to reach the node *before* the one to be deleted: `temp_node = temp_node->next`."
          },
          {
            "step": "Identify the node to delete: `node_to_delete = temp_node->next`."
          },
          {
            "step": "Store the data from the node to be deleted: `deleted_element = node_to_delete->data`."
          },
          {
            "step": "Bypass the node to delete: `temp_node->next = node_to_delete->next`."
          },
          {
            "step": "Deallocate `node_to_delete` (using `delete_node` logic)."
          },
          {
            "step": "Return `deleted_element`."
          }
        ]
      }
    ]
  },
    {
    "algorithm": "LList Reverse Sublist (using auxiliary array)",
    "input": [
      "start: The starting zero-based index of the sublist to reverse.",
      "end: The ending zero-based index of the sublist to reverse."
    ],
    "output": [
      "Returns `true` if the reversal is successful, `false` otherwise.",
      "The elements in the list between indices `start` and `end` (inclusive) are reversed."
    ],
    "steps": [
        {
          "step": "Check if `start < 0` or `end >= count`."
        },
        {
          "step": "If indices are invalid, return `false`."
        },
        {
          "step": "Allocate a temporary array `temp_array` and copy the elements from the list from index `start` to `end` into it (using `alloccopy(start, end)`)."
        },
        {
            "step": "Let `temp_array_size` be the number of elements copied."
        },
        {
            "step": "Reverse the elements within `temp_array` in place.",
            "substeps": [
                {
                    "step": "Iterate with index $i$ from $0$ to `floor(temp_array_size / 2) - 1`:",
                    "substeps": [
                        {
                            "step": "Swap `temp_array[i]` with `temp_array[temp_array_size - 1 - i]`."
                        }
                    ]
                }
            ]
        },
        {
            "step": "Delete the original nodes from the list corresponding to the range `start` to `end`.",
             "substeps": [
                {
                    "step": "Iterate with index $j$ from `start` to `end`:",
                    "substeps": [
                        {
                            "step": "Delete the node currently at index `start` using `deletepos(start)`."
                        }
                    ]
                }
             ]
        },
        {
            "step": "Insert the reversed elements from `temp_array` back into the list starting at index `start`.",
            "substeps": [
                 {
                    "step": "Initialize `array_index = 0`."
                 },
                {
                    "step": "Iterate with index $k$ from `start` to `end`:",
                    "substeps": [
                        {
                            "step": "Insert `temp_array[array_index]` at list position $k$ using `insertpos(temp_array[array_index], k)`."
                        },
                        {
                           "step": "Increment `array_index`."
                        }
                    ]
                }
            ]
        },
        {
            "step": "Deallocate the `temp_array`."
        },
        {
            "step": "Return `true`."
        }
    ]
  },
  {
    "algorithm": "LList Linear Search",
    "input": [
      "ele: The integer element to search for."
    ],
    "output": [
      "Returns the zero-based index of the first occurrence of `ele` if found.",
      "Returns -1 if `ele` is not found in the list."
    ],
    "steps": [
      {
        "step": "Initialize `current_node = head`."
      },
      {
        "step": "Iterate with index $i$ from $0$ to `count - 1`:",
        "substeps": [
          {
            "step": "If `current_node->data` equals `ele`:",
            "substeps": [
              {
                "step": "Return the current index $i$."
              }
            ]
          },
          {
            "step": "Move to the next node: `current_node = current_node->next`."
          }
        ]
      },
      {
        "step": "If the loop completes without finding the element, return -1."
      }
    ]
  },
    {
    "algorithm": "LList Get Element (Circular)",
    "input": [
      "pos: The (unsigned) zero-based index from which to retrieve the element."
    ],
    "output": [
      "Returns the integer element at the effective position.",
      "Throws an exception or indicates an error if `pos` implies an invalid operation or the list is empty."
    ],
    "steps": [
       {
         "step": "Check if the list is empty (`count == 0`) or if `pos` represents an invalid scenario (e.g., negative input interpreted incorrectly)."
       },
       {
         "step": "If invalid, throw an exception or signal an error ('Invalid position')."
       },
       {
           "step": "Calculate the effective index within the current list bounds: `effective_pos = pos % count`."
       },
       {
           "step": "Initialize `current_node = head`."
       },
       {
           "step": "Iterate `effective_pos` times:",
           "substeps": [
                {
                    "step": "`current_node = current_node->next`."
                }
           ]
       },
       {
           "step": "Return the data from the reached node: `current_node->data`."
       }
    ]
  },
   {
    "algorithm": "LList Set Element",
    "input": [
      "pos: The zero-based index of the element to modify.",
       "value: The new integer value for the element."
    ],
    "output": [
      "Returns `true` if the update is successful, `false` otherwise.",
       "The data of the node at index `pos` is updated to `value`."
    ],
    "steps": [
        {
           "step": "Check if `pos < 0` or `pos >= count`."
       },
        {
           "step": "If invalid, return `false`."
       },
        {
           "step": "Initialize `current_node = head`."
       },
       {
           "step": "Iterate `pos` times:",
            "substeps": [
                {
                    "step": "`current_node = current_node->next`."
                }
           ]
       },
       {
           "step": "Update the data of the reached node: `current_node->data = value`."
       },
        {
            "step": "Return `true`."
        }
    ]
  }
]
