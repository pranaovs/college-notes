[
  {
    "algorithm": "Hash Table Insert with Linear Probing",
    "input": [
      "key - The integer value to insert into the hash table."
    ],
    "output": [
      "Prints a message indicating success (with index) or failure (table full)."
    ],
    "steps": [
      {
        "step": "Calculate the initial hash index: `index = hash(key)` (key % TABLE_SIZE)."
      },
      {
        "step": "Store the starting index for wrap-around check: `startIndex = index`."
      },
      {
        "step": "Check the initial slot `table[index]`:",
        "substeps": [
          {
            "step": "If `table[index]` is not occupied (`!isOccupied`) OR it is marked as deleted (`isDeleted`):",
            "substeps": [
              {
                "step": "Store the `key` in `table[index].data`."
              },
              {
                "step": "Mark the slot as occupied: `table[index].isOccupied = true`."
              },
              {
                "step": "Mark the slot as not deleted: `table[index].isDeleted = false`."
              },
              {
                "step": "Print insertion success message with the index."
              },
              {
                "step": "Return (insertion complete)."
              }
            ]
          }
        ]
      },
      {
        "step": "If the initial slot is occupied and not deleted, start linear probing:"
      },
      {
        "step": "Calculate the next probe index: `index = (index + 1) % TABLE_SIZE`."
      },
      {
        "step": "While the current `index` is not equal to the `startIndex` (to prevent infinite loop in a full table):",
        "substeps": [
          {
            "step": "If `table[index]` is not occupied (`!isOccupied`) OR it is marked as deleted (`isDeleted`):",
            "substeps": [
               {
                "step": "Store the `key` in `table[index].data`."
              },
              {
                "step": "Mark the slot as occupied: `table[index].isOccupied = true`."
              },
              {
                "step": "Mark the slot as not deleted: `table[index].isDeleted = false`."
              },
              {
                "step": "Print insertion success message with the index."
              },
              {
                "step": "Return (insertion complete)."
              }
            ]
          },
          {
              "step": "Calculate the next probe index: `index = (index + 1) % TABLE_SIZE`."
          }
        ]
      },
      {
        "step": "If the loop completes without returning (meaning `index == startIndex`), print 'The table is full'."
      }
    ]
  },
  {
    "algorithm": "Hash Table Remove (Lazy Deletion) with Linear Probing",
    "input": [
      "key - The integer value to remove from the hash table."
    ],
    "output": [
      "Prints a message indicating success (with index) or failure (not found)."
    ],
    "steps": [
       {
        "step": "Calculate the initial hash index: `index = hash(key)` (key % TABLE_SIZE)."
      },
      {
        "step": "Store the starting index for wrap-around check: `startIndex = index`."
      },
      {
        "step": "Start probing from the initial index:",
        "substeps": [
            {
              "step": "Check the current slot `table[index]`:" ,
              "substeps": [
                 {
                     "step": "If the slot is occupied (`isOccupied`), contains the correct key (`data == key`), and is not already marked as deleted (`!isDeleted`):",
                     "substeps": [
                        {
                           "step": "Mark the slot as deleted: `table[index].isDeleted = true`."
                        },
                         {
                           "step": "Print removal success message with the index."
                        },
                        {
                            "step": "Return (removal complete)."
                        }
                     ]
                 }
              ]
            }
        ]
      },
      {
        "step": "If not found at the initial slot, continue linear probing:"
      },
      {
          "step": "Calculate the next probe index: `index = (index + 1) % TABLE_SIZE`."
      },
       {
        "step": "While the current `index` is not equal to the `startIndex`:",
        "substeps": [
           {
             "step": "Check the current slot `table[index]`:" ,
             "substeps": [
                {
                    "step": "If the slot is occupied (`isOccupied`), contains the correct key (`data == key`), and is not already marked as deleted (`!isDeleted`):",
                    "substeps": [
                       {
                          "step": "Mark the slot as deleted: `table[index].isDeleted = true`."
                       },
                        {
                          "step": "Print removal success message with the index."
                       },
                       {
                           "step": "Return (removal complete)."
                       }
                    ]
                },
                 {
                     "step": "If the slot is not occupied (`!isOccupied`) [and not marked deleted - implicitly handled by loop condition in search]:",
                     "substeps": [
                         {
                             "step": "The key cannot be further down the probe sequence. Break the loop."
                         }
                     ]
                 }
             ]
           },
           {
               "step": "Calculate the next probe index: `index = (index + 1) % TABLE_SIZE`."
           }
        ]
      },
      {
           "step": "If the loop completes without returning, print 'Element not found'."
      }
    ]
  },
  {
    "algorithm": "Hash Table Search with Linear Probing",
    "input": [
      "key - The integer value to search for in the hash table."
    ],
    "output": [
      "Prints a message indicating whether the element was found (with index) or not."
    ],
    "steps": [
        {
        "step": "Calculate the initial hash index: `index = hash(key)` (key % TABLE_SIZE)."
      },
      {
        "step": "Store the starting index for wrap-around check: `startIndex = index`."
      },
       {
        "step": "Start probing from the initial index:",
        "substeps": [
            {
                "step": "Check the current slot `table[index]`:",
                "substeps": [
                    {
                        "step": "If the slot is occupied (`isOccupied`), contains the correct key (`data == key`), and is not marked as deleted (`!isDeleted`):",
                        "substeps": [
                            {
                               "step": "Print found message with the index."
                            },
                            {
                                "step": "Return (search complete)."
                            }
                        ]
                    }
                ]
            }
        ]
      },
       {
        "step": "If not found at the initial slot, continue linear probing:"
      },
      {
          "step": "Calculate the next probe index: `index = (index + 1) % TABLE_SIZE`."
      },
      {
        "step": "While the current `index` is not equal to the `startIndex` AND the current slot `table[index]` is occupied (`isOccupied`):",
        "substeps": [
          {
            "step": "If the slot contains the correct key (`data == key`) AND is not marked as deleted (`!isDeleted`):",
             "substeps": [
                {
                   "step": "Print found message with the index."
                },
                {
                    "step": "Return (search complete)."
                }
             ]
          },
          {
              "step": "Calculate the next probe index: `index = (index + 1) % TABLE_SIZE`."
          }
        ]
      },
      {
           "step": "If the loop completes without returning (either wrapped around or hit an unoccupied slot), print 'Element not found'."
      }
    ]
  }
]
