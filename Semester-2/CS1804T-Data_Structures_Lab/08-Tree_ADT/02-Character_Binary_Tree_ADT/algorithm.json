[
  {
    "algorithm": "Tree Insert (Skewed)",
    "input": [
      "x - The character data to insert into the tree."
    ],
    "output": [
      "None (Tree structure is modified)."
    ],
    "steps": [
      {
        "step": "Create a new node `temp`."
      },
      {
        "step": "Set `temp->data = x`."
      },
      {
        "step": "Set `temp->left = NULL`."
      },
      {
        "step": "Set `temp->right = NULL`."
      },
      {
        "step": "If the tree is empty (`root == NULL`):",
        "substeps": [
          {
            "step": "Set `root = temp`."
          }
        ]
      },
      {
        "step": "Else (tree is not empty):",
        "substeps": [
          {
            "step": "Initialize a pointer `p = root`."
          },
          {
            "step": "While `p` has both left and right children (`p->left != NULL` AND `p->right != NULL`):",
            "substeps": [
              {
                "step": "If `p->left` is not NULL:",
                 "substeps": [
                    {
                        "step": "Move `p` to its left child: `p = p->left`."
                    }
                ]
              },
              {
                "step": "Else (meaning `p->left` is NULL, but this condition won't be met inside the while loop):",
                 "substeps": [
                    {
                        "step": "Move `p` to its right child: `p = p->right`."
                    }
                ]
              }
            ]
          },
          {
            "step": "After the loop, `p` points to a node with at least one NULL child."
          },
          {
            "step": "If `p->left` is NULL:",
            "substeps": [
                {
                    "step": "Set `p->left = temp`."
                }
            ]
          },
          {
            "step": "Else (meaning `p->left` is not NULL, so `p->right` must be NULL):",
            "substeps": [
                {
                     "step": "Set `p->right = temp`."
                }
            ]
          }
        ]
      }
    ]
  },
  {
    "algorithm": "Tree Inorder Traversal (Recursive)",
    "input": [
      "p - A pointer to the current node (initially the root)."
    ],
    "output": [
      "Prints the data of nodes in inorder sequence to standard output."
    ],
    "steps": [
      {
        "step": "If the current node `p` is not NULL:",
        "substeps": [
          {
            "step": "Recursively call `inorder` on the left child: `inorder(p->left)`."
          },
          {
            "step": "Print the data of the current node: `cout << p->data`."
          },
          {
            "step": "Recursively call `inorder` on the right child: `inorder(p->right)`."
          }
        ]
      }
    ]
  },
  {
    "algorithm": "Tree Postorder Traversal (Recursive)",
    "input": [
      "p - A pointer to the current node (initially the root)."
    ],
    "output": [
      "Prints the data of nodes in postorder sequence to standard output."
    ],
    "steps": [
      {
        "step": "If the current node `p` is not NULL:",
        "substeps": [
          {
            "step": "Recursively call `postorder` on the left child: `postorder(p->left)`."
          },
          {
            "step": "Recursively call `postorder` on the right child: `postorder(p->right)`."
          },
          {
            "step": "Print the data of the current node: `cout << p->data`."
          }
        ]
      }
    ]
  },
  {
    "algorithm": "Tree Preorder Traversal (Recursive)",
    "input": [
      "p - A pointer to the current node (initially the root)."
    ],
    "output": [
      "Prints the data of nodes in preorder sequence to standard output."
    ],
    "steps": [
      {
        "step": "If the current node `p` is not NULL:",
        "substeps": [
          {
            "step": "Print the data of the current node: `cout << p->data`."
          },
          {
            "step": "Recursively call `preorder` on the left child: `preorder(p->left)`."
          },
          {
            "step": "Recursively call `preorder` on the right child: `preorder(p->right)`."
          }
        ]
      }
    ]
  },
  {
    "algorithm": "Tree Search (Skewed Path)",
    "input": [
      "x - The character data to search for."
    ],
    "output": [
      "Prints 'Element found' or 'Element not found' to standard output."
    ],
    "steps": [
      {
        "step": "Initialize a pointer `p = root`."
      },
      {
        "step": "While `p` is not NULL:",
        "substeps": [
          {
            "step": "If the data in the current node matches `x` (`p->data == x`):",
            "substeps": [
                {
                    "step": "Print 'Element found'."
                },
                {
                    "step": "Return (exit the function)."
                }
            ]
          },
          {
            "step": "Else (data does not match):",
            "substeps": [
              {
                "step": "If `p->left` is not NULL:",
                "substeps": [
                    {
                         "step": "Move `p` to its left child: `p = p->left`."
                    }
                ]
              },
              {
                "step": "Else (left child is NULL):",
                "substeps": [
                    {
                        "step": "Move `p` to its right child: `p = p->right`."
                    }
                ]
              }
            ]
          }
        ]
      },
      {
        "step": "If the loop finishes (meaning `p` became NULL without finding `x`):" ,
        "substeps": [
           {
               "step": "Print 'Element not found'."
           }
        ]

      }
    ]
  }
]
